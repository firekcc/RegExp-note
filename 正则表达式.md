### 定义
- [Regular Expression](https://en.wikipedia.org/wiki/Regular_expression)使用单个字符串来描述、匹配一系列符合 `某个句法规则`的字符串
- 说简单了就是按照某种`规则`去匹配符合条件的字符串 

### 正则表达式可视化工具
- https://regexper.com/

### 用途：查找和替换和验证  

### REGEXP对象  
- JavaScript通过内置对象RegExp支持正则表达式
- 有两种方法实例化RegExp对象
  1. 字面量
  2. 构造函数

`var reg = /\bis\b/g`  

`var reg = new RegExp('\\bis\\b' , 'g')`  

##### 修饰符
- g：global全文搜索，不添加 , 搜索到第一个匹配停止
- i：ignore case 忽略大小写，默认大小写敏感
- m：multiple lines 多行搜索  

##### 元字符
- 原义文本字符 eg：abc，123

- 元字符 eg: \b

> 元字符是在正则表达式中有特殊含义的非字母字符

     * + ? $ ^ . | \ ( ) { } [ ]


字符  | 含义
---   | ---
\t    | 水平制表符
\v    | 垂直制表符
\n    | 换行符
\r    | 回车符
\0    | 空字符
\f    | 换页符
\cX   | 与X对应的控制字符(Ctrl + X) 

##### 字符类
- 一般情况下正则表达式一个字符对应字符串一个字符
- 我们可以使用元字符[]来构建一个简单的类
- 所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符
- 表达式[abc]把字符a或b或c归为一类，表达式可以匹配这类的字符

##### 字符类取反
- 使用元字符^创建 `反向类/负向类`
- 反向类的意思是不属于某类的内容
- 表达式 **`[^abc]`** 表示`不是字符a或b或c的内容`


##### 范围类
使用字符类匹配数字 ==[0123456789]==  

- 我们可以使用[a-z]来链接两个字符表示`从a到z的任意字符`  
- 这是个闭区间，也就是包含a和z本身
- 在[ ]组成的类内部是可以连写的 ==[a-zA-Z]==




##### 预定义类
正则表达式提供 ==预定义类== 来匹配常见的字符类


字符  |  等价类   |        含义
---   |  ---      |   ---
.     | [^\r\n]   |除了回车符和换行符之外的所有字符
\d    | [0-9]     |数字字符
\D    | [^0-9]    |非数字字符
\s    | [\t\n\x0B\f\r] | 空白字符
\S    | [^\t\n\x0B\f\r] | 非空白字符
\w    | [a-zA-Z_0-9]    | 单词字符
\W    | [^a-zA-Z_0-9]   | 非单词字符



匹配一个 ==`ab+数字+任意字符`== 的字符串

ab[0-9][^\r\n]  
ab\d.


##### 边界
**正则表达式提供了几个常用的边界匹配字符**

字符    | 含义
---     | ---
^       | 以xxx开始
$       | 以xxx结束
\b      | 单词边界
\B      | 非单词边界







##### 量词
我们希望匹配一个连续出现 ==20次== 数字的字符串  
\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d
\d{20}

字符    | 含义
---     | ---
?       | 出现零次或一次(最多出现一次)
+       | 出现一次或多次(至少出现一次)
*       | 出现零次或多次(任意次)
{n}     | 出现n次
{n,m}   | 出现n到m次
{n,}    | 至少出现n次

\d{20}\w\d?\w+\d*\d{3}\w{3,5}\d{3,}\d{0,9}




##### JS正则贪婪模式与非贪婪模式
- 贪婪模式  
'12345678'.replace(/\d{3,6}/g,'X')

- 非贪婪模式  
     让正则表达式尽可能少的匹配，也就是说一旦成功匹 配不再继续尝试就是非贪婪模式
     做法很简单，在量词后加上?即可

'123456789'.match(/\d{3,5}?/g)
    

##### 分组
匹配字符串Byron连续出现3次的场景  
ByronByronByron  
error：Byron{3}  
使用( )可以达到分组的功能，使量词作用于分组  
success：(Byron){3}


'a1b2c3d4'.replace(/[a-z]\d{3}/,'x')


##### 或
使用 | 可以达到或的效果

'ByronCasper'.replace(/Byron|Casper/g,'X')

'ByronsperByrCasper'.replace(/Byr(on|Ca)sper/g,'X')



##### 反向引用

2016-12-26=>12/26/2016

'2016-12-26'.replace(/(\d{4})-(\d{2})-(\d{2})/g,'$2$3$1')

##### 忽略分组

不需要捕获某些分组，只需要在分组内加上?:就可以了

==(?:Byron).(ok)==

##### 前瞻
- 正则表达式从文本头部向尾部开始解析，文本尾部方向，称为"前”  
- 前瞻就是在正则表达式匹配到规则的时候，向前检查是否符合断言，后顾/后瞻方向相反
- JavaScript不支持后顾
- 符合和不符合特定断言称为肯定/正向匹配和否定/负向匹配

名称        |  正则            |        含义
---         |   ---            |   ---
正想前瞻    | exp(?=assert)    |
负向前瞻    | exp(?=assert)    |
正向后顾    | exp(?=assert)    | JavaScript不支持
负向后顾    | exp(?=assert)    | JavaScript不支持

'a2*34vv'.replace(/\w(?=\d)/g,'X')  
'a2*34vv'.replace(/\w(?!\d)/g,'X')


##### 对象属性
- global：是否全文搜索，默认false
- ignore case：是否大小写敏感，默认false
- multiline：多行搜索，默认值false
- lastIndex：是当前表达式匹配内容的最后一个字符的下一个位置
- source： 正则表达式的文本字符串


##### jsbin.com

reg.test(str)  
reg.exec(str)

str.search(reg)  
str.match(reg)
str.split(reg)  
str.replace(str,replaceStr)  
str.replace(reg,replaceStr)  
str.replace(reg,function)



邮箱：`^[a-zA-Z0-9]{4,}@[a-z0-9A-Z]{2,}\\.[a-zA-Z]{2,}$ `  

手机号码：`^((13[0-9])|(15[^4\\D])|(18[0,2,5-9]))\\d{8}$`  

大陆固定电话号码：`^\\d{4}-|\\d{3}-)?(\\d{8}|\\d{7}$`  

身份证号：`\\d{14}[[0-9],0-9xX]`  

Email地址：`^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\.\\w+([-.]\\w+)*$  `  

纯数字：`^[0-9]*$ `   

由数字和英文字母组成：`^[A-Za-z0-9]+$ ` 

QQ号：`^[1-9][0-9]\{4,\}$`  

中国邮政编码：`^[1-9]\\d{5}(?!\\d)$ ` 

URL：^http(s)?:`//([\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&=]*)?$`  

纯汉字：`^[\u4e00-\u9fa5]{0,}$ ` 

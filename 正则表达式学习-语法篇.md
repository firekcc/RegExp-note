### 定义
- [Regular Expression](https://en.wikipedia.org/wiki/Regular_expression)使用单个字符串来描述、匹配一系列符合 `某个句法规则`的字符串
- 说简单了就是按照某种`规则`去匹配符合条件的字符串 
---
### 可视化编辑工具
工欲善其事，必先利其器，为了更好理解正则表达式语法，可以使用一款正则表达式可视化编辑工具，比较受欢迎的有[Regulex](https://jex.im/regulex/#!embed=false&flags=&re=%5E(a%7Cb)*%3F%24) [Rubular](http://rubular.com/r/xfQHocREGj) [Pyregex](http://www.pyregex.com/) [Regexper](https://regexper.com/) 这些，它们都是在github上开源的工具，本人更喜欢简洁风格的Regexper。  

---
### 语法

> [\\w!#$%&'*+/=?^_`{|}~-]+(?:\\.[\\w!#$%&'*+/=?^_`{|}~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+\[\\w](?:[\\w-]*[\\w])?

不要看到一连串乱七八糟的正则表达式就失去征服它的动力，比如上面校验email地址的正则表达式，看起来是不是很迷惑呢？再复杂的东西都有其简单的构造元素，接下来看看正则表达式都有哪些基本语法吧

- ###### 修饰符
>  当我们不添加修饰符时，默认一般都是false。
>  - g：global全文搜索，不添加 , 搜索到第一个匹配停止
>  - i：ignore case 忽略大小写，默认大小写敏感
>  - m：multiple lines 多行搜索 

- ###### 元字符
  - 原义文本字符  
     `eg：abc，123`
  - 元字符   
     `eg: \b`     

> 元字符是在正则表达式中有特殊含义的非字母字符

     * + ? $ ^ . | \ ( ) { } [ ]

字符  | 含义
---   | ---
\t    | 水平制表符
\v    | 垂直制表符
\n    | 换行符
\r    | 回车符
\0    | 空字符
\f    | 换页符
\cX   | 与X对应的控制字符(Ctrl + X) 

- ###### 字符类
> - 一般情况下正则表达式一个字符对应字符串一个字符
> - 我们可以使用元字符[]来构建一个简单的类
> - 所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符
> - 表达式[abc]把字符a或b或c归为一类，表达式可以匹配这类的字符

- ###### 字符类取反
> - 使用元字符^创建 `反向类/负向类`
> - 反向类的意思是不属于某类的内容
> - 表达式 **`[^abc]`** 表示`不是字符a或b或c的内容`

- ###### 范围类
> 使用字符类匹配数字 ==[0123456789]==  

> - 我们可以使用[a-z]来链接两个字符表示`从a到z的任意字符`  
> - 这是个闭区间，也就是包含a和z本身
> - 在[ ]组成的类内部是可以连写的 ==[a-zA-Z]==

- ###### 预定义类
> 正则表达式提供 ==预定义类== 来匹配常见的字符类


字符  |  等价类   |        含义
---   |  ---      |   ---
.     | [^\r\n]   |除了回车符和换行符之外的所有字符
\d    | [0-9]     |数字字符
\D    | [^0-9]    |非数字字符
\s    | [\t\n\x0B\f\r] | 空白字符
\S    | [^\t\n\x0B\f\r] | 非空白字符
\w    | [a-zA-Z_0-9]    | 单词字符
\W    | [^a-zA-Z_0-9]   | 非单词字符


> 匹配一个 ==`ab+数字+任意字符`== 的字符串

    ab[0-9][^\r\n]  
    ab\d.

- ###### 边界
> **正则表达式提供了几个常用的边界匹配字符**

字符    | 含义
---     | ---
^       | 以xxx开始
$       | 以xxx结束
\b      | 单词边界
\B      | 非单词边界

- ###### 量词
> 我们希望匹配一个连续出现 ==20次== 数字的字符串  
\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d
\d{20}

字符    | 含义
---     | ---
?       | 出现零次或一次(最多出现一次)
+       | 出现一次或多次(至少出现一次)
*       | 出现零次或多次(任意次)
{n}     | 出现n次
{n,m}   | 出现n到m次
{n,}    | 至少出现n次

    \d{20}\w\d?\w+\d*\d{3}\w{3,5}\d{3,}\d{0,9}

- ###### 贪婪模式与非贪婪模式
> - 贪婪模式  

      '12345678'.replace(/\d{3,6}/g,'X')

> - 非贪婪模式  

     让正则表达式尽可能少的匹配，也就是说一旦成功匹 配不再继续尝试就是非贪婪模式
     做法很简单，在量词后加上?即可

     '123456789'.match(/\d{3,5}?/g)

- ###### 分组
> 匹配字符串Byron连续出现3次的场景  
ByronByronByron  
error：Byron{3}  
使用( )可以达到分组的功能，使量词作用于分组  
success：(Byron){3}


    'a1b2c3d4'.replace(/[a-z]\d{3}/,'x')

- ###### 或
> 使用 | 可以达到或的效果
'ByronCasper'.replace(/Byron|Casper/g,'X')
'ByronsperByrCasper'.replace(/Byr(on|Ca)sper/g,'X')

- ###### 反向引用
> 2016-12-26=>12/26/2016

     '2016-12-26'.replace(/(\d{4})-(\d{2})-(\d{2})/g,'$2$3$1')

- ###### 忽略分组
> 不需要捕获某些分组，只需要在分组内加上?:就可以了

     ==(?:Byron).(ok)==

---

### 相关优质资源
[Java 正则表达式(精华)](http://www.jianshu.com/p/984b5e31868e)  
[常用正则表达式](http://www.jianshu.com/p/0cb001fe3572)  
[知道这20个正则表达式，能让你少写1,000行代码](http://www.jianshu.com/p/e7bb97218946)  
[30分钟玩转「正则表达式」](http://www.jianshu.com/p/27c8b26faa9b)

